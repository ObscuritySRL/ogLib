function tMainScreen.getHorizontalDegrees():int32;
  var
    funcAngle:double;
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        funcAngle:=arcTan2(funcView[1],funcView[0]);
        if funcAngle>0 then
          result:=round(funcAngle*360/(2*3.1415926535897932384626433832795))
        else
          result:=round((2*3.1415926535897932384626433832795+funcAngle)*360/(2*3.1415926535897932384626433832795));
      end;
    exit(result);
  end;

function tMainScreen.getHorizontalRadians():double;
  var
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        result:=arcTan2(funcView[1],funcView[0]);
        if result<0 then
          result:=2*3.1415926535897932384626433832795+result;
      end;
        exit(result);
  end;

function tMainScreen.getVerticalDegrees():int32;
  var
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        result:=round(90-funcView[5]*90);
      end;
    exit(result);
  end;

function tMainScreen.getVerticalRadians():double;
  var
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        result:=1.5707963267948966192313216916398-funcView[5]*1.5707963267948966192313216916398;
      end;
    exit(result);
  end;

function tMainScreen.getDegrees(var funcHorizontal,funcVertical:int32):boolean;
  var
    funcAngle:double;
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        funcAngle:=arcTan2(funcView[1],funcView[0]);
        if funcHorizontal>0 then
          funcHorizontal:=round(funcAngle*360/(2*3.1415926535897932384626433832795))
        else
          funcHorizontal:=round((2*3.1415926535897932384626433832795+funcAngle)*360/(2*3.1415926535897932384626433832795));
        funcVertical:=round(90-funcView[5]*90);
        result:=true;
      end;
    exit(result);
  end;

function tMainScreen.getDegrees():array[0..1] of int32;overload;
  var
    funcAngle:double;
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        funcAngle:=arcTan2(funcView[1],funcView[0]);
        if funcAngle>0 then
          result[0]:=round(funcAngle*360/(2*3.1415926535897932384626433832795))
        else
          result[0]:=round((2*3.1415926535897932384626433832795+funcAngle)*360/(2*3.1415926535897932384626433832795));
        result[1]:=round(90-funcView[5]*90);
      end;
    exit(result);
  end;

function tMainScreen.getRadians(var funcHorizontal,funcVertical:double):boolean;
  var
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        funcHorizontal:=arcTan2(funcView[1],funcView[0]);
        if funcHorizontal<0 then
          funcHorizontal:=2*3.1415926535897932384626433832795+funcHorizontal;
        funcVertical:=1.5707963267948966192313216916398-funcView[5]*1.5707963267948966192313216916398;
        result:=true;
      end;
    exit(result);
  end;

function tMainScreen.getRadians():array[0..1] of double;overload;
  var
    funcPointer:pointer;
    funcView:array[0..15] of single;
  begin
    if (funcPointer:=glMatrices())<>nil then
      begin
        funcView:=funcPointer^;
        result[0]:=arcTan2(funcView[1],funcView[0]);
        if result[0]<0 then
          result[0]:=2*3.1415926535897932384626433832795+result[0];
        result[1]:=1.5707963267948966192313216916398-funcView[5]*1.5707963267948966192313216916398;
      end;
    exit(result);
  end;

function tMainscreen.getXP(skill: string): integer;
var
  i, skillID: uint32;
  skillTextures: glTextureArray;
  skillBoxTexture: glTexture;
  skillBox: TBox;
begin
  case lowercase(skill) of
    'attack': skillID := 16918;
    'strength': skillID := 39319;
    'defence': skillID := 41952;
    'range': skillID := 20999;
    'magic': skillID := 51211;
    'constitution': skillID := 38262;
    'thieving': skillID := 25506;
    'crafting': skillID := 33559;
    'fletching': skillID := 19315;
    'mining': skillID := 16653;
    'smithing': skillID := 31773;
    'fishing': skillID := 54626;
    'runecrafting': skillID := 33877;
    'slayer': skillID := 64733;
    'farming': skillID := 34536;
    'construction': skillID := 54189;
    'hunter': skillID := 30306;
    'summoning': skillID := 37582;
    'prayer': skillID := 23912;
    'agility': skillID := 29580;
    'herblore': skillID := 54427;
    'cooking': skillID := 47376;
    'firemaking': skillID := 46008;
    'woodcutting': skillID := 44243;
    'dungeoneering': skillID := 58390;
    'divination': skillID := 22933;
    'combat': skillID := 31110;
    'overall': skillID := 48705;
  end;
  skillTextures:=ogl.getTextures(skillID);
  if skillTextures.isEmpty() then
    exit(result-1);
  skillBoxTexture:=skillTextures[low(skillTextures)];
  skillBox:=skillBoxTexture.bounds.adjustPosition(-150, 0, 0, 0);
  result := explode('+', ogl.getChars(skillBox).toString())[0].parseInt();
end;

function tMainScreen.setDegrees(funcHorizontal,funcVertical:int32):boolean;
  begin exit(result:=tMainScreen.setRadians(funcHorizontal*0.01745329251994329576923690768489,funcVertical*0.01745329251994329576923690768489));end;

function tMainScreen.setHorizontalDegrees(funcDegrees:int32):boolean;
  begin exit(result:=tMainScreen.setHorizontalRadians(funcDegrees*0.01745329251994329576923690768489));end;

function tMainScreen.setHorizontalDirection(funcDirection:ansiString):boolean;
  var
    funcAngle:double;
  begin
    case (funcDirection:=replace(lowerCase(funcDirection),' ','-',[0,1])) of
      'north':funcAngle:=0;
      'north-west':funcAngle:=0.78539816339744830961566084581988;
      'west':funcAngle:=1.5707963267948966192313216916401;
      'south-west':funcAngle:=2.3561944901923449288469825374602;
      'south':funcAngle:=3.1415926535897932384626433832795;
      'south-east':funcAngle:=3.9269908169872415480783042291003;
      'east':funcAngle:=4.7123889803846898576939650749203;
      'north-east':funcAngle:=5.4977871437821381673096259207404;
    end;
    exit(result:=tMainScreen.setHorizontalRadians(funcAngle));
  end;

function tMainScreen.setHorizontalRadians(funcRadians:double):boolean;
  var
    funcDifference:double;
    funcLeft,
      funcRight,
      funcTimedOut:boolean;
    funcTimeOut:tCountDown;
  begin
    funcTimeOut.setTime(random(2500,5000));
    while (abs(funcDifference:=shortestRadians(tMainScreen.getHorizontalRadians(),funcRadians))>oglAngleTolerance) and not (funcTimedOut:=funcTimeOut.isFinished()) do
      begin
        funcLeft:=isKeyDown(37);
        funcRight:=isKeyDown(39);
        if funcDifference<0 then
          begin
            if funcRight then
              keyUp(39);
            if funcLeft then
              continue;
            keyDown(37);
          end
        else
          begin
            if funcLeft then
              keyUp(37);
            if funcRight then
              continue;
            keyDown(39);
          end;
      end;
    if isKeyDown(37) then
      keyUp(37);
    if isKeyDown(39) then
      keyUp(39);
    exit(result:=not funcTimedOut);
  end;

function tMainScreen.setVerticalDegrees(funcDegrees:int32):boolean;
  begin exit(result:=tMainScreen.setVerticalRadians(funcDegrees*0.01745329251994329576923690768489));end;

function tMainScreen.setVerticalDirection(funcDirection:ansiString):boolean;
  var
    funcAngle:double;
  begin
    case (funcDirection:=replace(lowerCase(funcDirection),' ','-',[0,1])) of
      'high','top','up':funcAngle:=0.87266462599716478846184538424431;
      'medium','middle':funcAngle:=0.43633231299858239423092269212215;
      'bottom','down','low':funcAngle:=0;
    end;
    exit(result:=tMainScreen.setVerticalRadians(funcAngle));
  end;

function tMainScreen.setVerticalRadians(funcRadians:double):boolean;
  var
    funcDifference:double;
    funcDown,
      funcUp,
      funcTimedOut:boolean;
    funcTimeOut:tCountDown;
  begin
    funcTimeOut.setTime(random(2500,5000));
    while (abs(funcDifference:=shortestRadians(tMainScreen.getVerticalRadians(),funcRadians))>oglAngleTolerance) and not (funcTimedOut:=funcTimeOut.isFinished()) do
      begin
        funcDown:=isKeyDown(38);
        funcUp:=isKeyDown(40);
        if funcDifference<0 then
          begin
            if funcDown then
              keyUp(38);
            if funcUp then
              continue;
            keyDown(40);
          end
        else
          begin
            if funcUp then
              keyUp(40);
            if funcDown then
              continue;
            keyDown(38);
          end;
      end;
    if isKeyDown(38) then
      keyUp(38);
    if isKeyDown(40) then
      keyUp(40);
    exit(result:=not funcTimedOut);
  end;

function tMainScreen.setRadians(funcHorizontal,funcVertical:double):boolean;
  var
    funcDown,
      funcLeft,
      funcRight,
      funcUp,
      funcTimedOut:boolean;
    funcHorizontalDifference,
      funcVerticalDifference:double;
    funcMoveHorizontal,
      funcMoveVertical:boolean;
    funcRadians:array[0..1] of double;
    funcTimeOut:tCountDown;
  begin
    funcTimeOut.setTime(random(2500,5000));
    funcMoveHorizontal:=abs(funcHorizontalDifference:=shortestRadians((funcRadians:=tMainScreen.getRadians())[0],funcHorizontal))>oglAngleTolerance;
    funcMoveVertical:=abs(funcVerticalDifference:=shortestRadians(funcRadians[1],funcVertical))>oglAngleTolerance;
    while (funcMoveHorizontal or funcMoveVertical) and not (funcTimedOut:=funcTimeOut.isFinished()) do
      begin
        funcDown:=isKeyDown(38);
        funcLeft:=isKeyDown(37);
        funcRight:=isKeyDown(39);
        funcUp:=isKeyDown(40);
        if funcMoveHorizontal:=abs(funcHorizontalDifference:=shortestRadians((funcRadians:=tMainScreen.getRadians())[0],funcHorizontal))>oglAngleTolerance then
          begin
            if funcHorizontalDifference<0 then
              begin
                if funcRight then
                  keyUp(39);
                if not funcLeft then
                  keyDown(37);
              end
            else
              begin
                if funcLeft then
                  keyUp(37);
                if not funcRight then
                  keyDown(39);
              end;
          end
        else
          begin
            if funcLeft then
              keyUp(37);
            if funcRight then
              keyUp(39);
          end;
        if funcMoveVertical:=abs(funcVerticalDifference:=shortestRadians(funcRadians[1],funcVertical))>oglAngleTolerance then
          begin
            if funcVerticalDifference<0 then
              begin
                if funcDown then
                  keyUp(38);
                if not funcUp then
                  keyDown(40);
              end
            else
              begin
                if funcUp then
                  keyUp(40);
                if not funcDown then
                  keyDown(38);
              end;
          end
        else
          begin
            if funcDown then
              keyUp(38);
            if funcUp then
              keyUp(40);
          end;
      end;
    if isKeyDown(38) then
      keyUp(38);
    if isKeyDown(37) then
      keyUp(37);
    if isKeyDown(39) then
      keyUp(39);
    if isKeyDown(40) then
      keyUp(40);
    exit(result:=not funcTimedOut);
  end;
