function ansiString.debug(funcClear:boolean = false):string;
var
  funcMessage,
    funcString:string;
begin
  if funcClear then
    clearDebug();
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > string[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'string[1..'+toStr(length(self))+']'+#13#10+funcMessage+self;
  end;
  writeLN(funcString);
  exit(self);
end;

function ansiString.parseInt():int32;
var
  funcIndex,
    funcLength:int32;
begin
  if (funcLength:=length(self)) then
    for funcIndex:=1 to funcLength do
      case self[funcIndex] of
        '0'..'9':result:=(strToInt(self[funcIndex])+result*10);
      end;
  exit(result);
end;

function ansiString.reverse():string;
var
  funcIndex,
    funcLength:uInt32;
begin
  if (funcLength:=length(self)) then
    for funcIndex:=0 to funcLength-1 do
      result:=result+self[funcLength-funcIndex];
  exit(result);
end;



function boolean.debug(funcClear:boolean = false):boolean;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'boolean'+#13#10+funcMessage+toStr(self));
  exit(self);
end;



function cardinal.debug(funcClear:boolean = false):cardinal;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'cardinal'+#13#10+funcMessage+toStr(self));
  exit(self);
end;



function char.debug(funcClear:boolean = false):char;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'char'+#13#10+funcMessage+toStr(self));
  exit(self);
end;


function extended.debug(funcClear:boolean = false):extended;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'extended'+#13#10+funcMessage+toStr(self));
  exit(self);
end;

function extended.isBetween(A,B:integer):boolean;
begin exit((self>=min(A,B)) and (self<=max(A,B)));end;



function glChar.adjustPosition(funcX,funcY:int32):glChar;
begin
  result:=self;
  result.x:=result.x+funcX;
  result.y:=result.y+funcY;
  result.translate[0]:=result.translate[0]+funcX;
  result.translate[1]:=result.translate[1]+funcY;
  result.bounds.x1:=result.bounds.x1+funcX;
  result.bounds.x1:=result.bounds.y1+funcY;
  result.bounds.x2:=result.bounds.x2+funcX;
  result.bounds.y2:=result.bounds.y2+funcY;
  exit(result);
end;

 function glChar.debug(funcClear:boolean=false):glChar;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'glChar'+#13#10+funcMessage+toStr(self));
  result:=self;
end;

function glChar.toPoint():tPoint;
begin result:=[self.x,self.y];end;

function glChar.distanceFrom(funcChar:glChar):extended;
begin result:=sqrt(pow(self.x-funcChar.x,2)+pow(self.y-funcChar.y,2));end;

function glChar.distanceFrom(funcModel:glModel):extended;overload;
begin result:=sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2));end;

function glChar.distanceFrom(funcTexture:glTexture):extended;overload;
begin result:=sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2));end;

function glChar.distanceFrom(funcPoint:tPoint):extended;overload;
begin result:=pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2);end;



function glCharArray.contains(funcString:ansiString):boolean;
var
  funcIndex,
    funcMatch:int32;
begin
  funcString:=replace(lowerCase(funcString),' ','',[0]);
  for funcIndex to high(self)-length(funcString) do
  begin
    if funcString[funcMatch+1]=lowerCase(self[funcIndex].letter) then
    begin
      if (funcMatch:=funcMatch+1)=length(funcString) then
      begin
        result:=true;
        break;
      end;
    end
    else
      funcMatch:=0;
  end;
  exit(result);
end;

function glCharArray.debug(funcClear:boolean=false):glCharArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > glCharArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > glCharArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  result:=self;
end;

function glCharArray.equals(funcChars:glCharArray):boolean;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    if not compareMem(@self[funcIndex],@funcChars[funcIndex],oglCharSize) then
      break
    else if funcIndex=high(self) then
      result:=true;
  exit(result);
end;

function glCharArray.first():glChar;
begin
  if length(self) then
    result:=self[0];
  exit(result);
end;

function glCharArray.getChars(funcTextureID:array of uInt32):glCharArray;
var
  funcPointer:^glChar;
  funcPointerIndex,
    funcResultIndex,
    funcTextureIDIndex:int32;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcPointerIndex to high(self) do
  begin
    if (funcPointerIndex=funcPointerSize-1) or (funcPointer^.x-(funcPointer+oglCharSize)^.x<>1) then
      for funcTextureIDIndex:=0 to high(funcTextureID) do
        if funcPointer^.textureID=funcTextureID[funcTextureIDIndex] then
        begin
          result[funcResultIndex]:=funcPointer^;
          funcResultIndex+=1;
          break;
        end;
    funcPointer+=oglCharSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.getChars(funcTextureID:uInt32):glCharArray;overload;
begin exit(self.getChars(tCardinalArray([funcTextureID])));end;

function glCharArray.getChars(funcTextureID:array of uInt32;funcColour:array of int32):glCharArray;overload;
var
  funcColourIndex,
    funcPointerIndex,
    funcResultIndex,
    funcTextureIDIndex:int32;
  funcPointer:^glChar;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcPointerIndex to high(self) do
  begin
    if (funcPointerIndex=funcPointerSize-1) or (funcPointer^.x-(funcPointer+oglCharSize)^.x<>1) then
      for funcTextureIDIndex:=0 to high(funcTextureID) do
        if funcPointer^.textureID=funcTextureID[funcTextureIDIndex] then
          for funcColourIndex:=0 to high(funcColour) do
            if similarColors(funcPointer^.colour,funcColour[funcColourIndex],oglColourTolerance) then
            begin
              result[funcResultIndex]:=funcPointer^;
              funcResultIndex+=1;
              funcTextureIDIndex:=high(funcTextureID);
              break;
            end;
    funcPointer+=oglCharSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.getChars(funcTextureID:uInt32;funcColour:int32):glCharArray;overload;
begin exit(self.getChars(tCardinalArray([funcTextureID]),[funcColour]));end;

function glCharArray.getChars(funcTextureID:array of uInt32;funcColour:array of int32;funcBounds:array of tBox):glCharArray;overload;
var
  funcBoundsIndex,
    funcColourIndex,
    funcPointerIndex,
    funcResultIndex,
    funcTextureIDIndex:int32;
  funcPointer:^glChar;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcPointerIndex to high(self) do
  begin
    if (funcPointerIndex=funcPointerSize-1) or (funcPointer^.x-(funcPointer+oglCharSize)^.x<>1) then
      for funcTextureIDIndex:=0 to high(funcTextureID) do
        if funcPointer^.textureID=funcTextureID[funcTextureIDIndex] then
          for funcColourIndex:=0 to high(funcColour) do
            if similarColors(funcPointer^.colour,funcColour[funcColourIndex],oglColourTolerance) then
              for funcBoundsIndex:=0 to high(funcBounds) do
                if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
                begin
                  result[funcResultIndex]:=funcPointer^;
                  funcResultIndex+=1;
                  funcTextureIDIndex:=high(funcTextureID);
                  funcColourIndex:=high(funcColour);
                  break;
                end;
    funcPointer+=oglCharSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.getChars(funcTextureID:uInt32;funcColour:int32;funcBounds:tBox):glCharArray;overload;
begin exit(self.getChars(tCardinalArray([funcTextureID]),[funcColour],[funcBounds]));end;

function glCharArray.getChars(funcTextureID:array of uInt32;funcBounds:array of tBox):glCharArray;overload;
var
  funcBoundsIndex,
    funcPointerIndex,
    funcResultIndex,
    funcTextureIDIndex:int32;
  funcPointer:^glChar;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcPointerIndex to high(self) do
  begin
    if (funcPointerIndex=funcPointerSize-1) or (funcPointer^.x-(funcPointer+oglCharSize)^.x<>1) then
      for funcTextureIDIndex:=0 to high(funcTextureID) do
        if funcPointer^.textureID=funcTextureID[funcTextureIDIndex] then
          for funcBoundsIndex:=0 to high(funcBounds) do
            if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
            begin
              result[funcResultIndex]:=funcPointer^;
              funcResultIndex+=1;
              funcTextureIDIndex:=high(funcTextureID);
              break;
            end;
    funcPointer+=oglCharSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.getChars(funcTextureID:uInt32;funcBounds:tBox):glCharArray;overload;
begin exit(self.getChars(tCardinalArray([funcTextureID]),[funcBounds]));end;

function glCharArray.getChars(funcBounds:array of tBox):glCharArray;overload;
var
  funcBoundsIndex,
    funcPointerIndex,
    funcResultIndex:int32;
  funcPointer:^glChar;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcPointerIndex to high(self) do
  begin
    if (funcPointerIndex=funcPointerSize-1) or (funcPointer^.x-(funcPointer+oglCharSize)^.x<>1) then
      for funcBoundsIndex:=0 to high(funcBounds) do
        if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
        begin
          result[funcResultIndex]:=funcPointer^;
          funcResultIndex+=1;
          break;
        end;
    funcPointer+=oglCharSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.getChars(funcBounds:tBox):glCharArray;overload;
begin exit(self.getChars([funcBounds]));end;

function glCharArray.indexes():integer;
  begin exit(length(self));end;

function glCharArray.isEmpty():boolean;
  begin exit(pointer(self)=nil);end;

function glCharArray.maxIndex():integer;
  begin exit(high(self));end;

function glCharArray.minIndex():int32;
  begin exit(low(self));end;

function glCharArray.last():glChar;
begin
  if length(self) then
    result:=self[high(self)];
  exit(result);
end;

function glCharArray.parseAlpha():glCharArray;
var
  funcResultIndex,
    funcSelfIndex:int32;
begin
  setLength(result,length(self));
  for funcSelfIndex to high(self) do
    case self[funcSelfIndex].letter of
      'A'..'Z','a'..'z':
      begin
        result[funcResultIndex]:=self[funcSelfIndex];
        funcResultIndex+=1;
      end;
    end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.parseAlphaNumeric():glCharArray;
var
  funcResultIndex,
    funcSelfIndex:int32;
begin
  setLength(result,length(self));
  for funcSelfIndex to high(self) do
    case self[funcSelfIndex].letter of
      '0'..'9','A'..'Z','a'..'z':
      begin
        result[funcResultIndex]:=self[funcSelfIndex];
        funcResultIndex+=1;
      end;
    end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.parseInt():glCharArray;
var
  funcResultIndex,
    funcSelfIndex:int32;
begin
  setLength(result,length(self));
  for funcSelfIndex to high(self) do
    case self[funcSelfIndex].letter of
      '0'..'9':
      begin
        result[funcResultIndex]:=self[funcSelfIndex];
        funcResultIndex+=1;
      end;
    end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glCharArray.reverse():glCharArray;
var
  funcIndex:int32;
  funcPointer:^glChar;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=oglCharSize;
  end;
  exit(result);
end;

function glCharArray.toInteger():int32;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    case self[funcIndex].letter of
      '0'..'9':result:=(strToInt(self[funcIndex].letter)+result*10);
    end;
  exit(result);
end;

function glCharArray.toString(funcSpacing:int32=3):string;
  var
    funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if length(self) then
      begin
        funcPointer:=pointer(self);
        for funcSelfIndex to high(self) do
          begin
            if (result<>'') and (abs(single((funcPointer+20)^)-(single((funcPointer-28)^)+integer((funcPointer-8)^)))>=funcSpacing) then
              result:=result+' ';
            if (funcPointer+16)^<>160 then
            result:=result+char((funcPointer+16)^);
            funcPointer:=funcPointer+48;
          end;
      end;
    exit(result);
  end;



function glModel.adjustPosition(funcX,funcY:integer=0):glModel;
begin
  result:=self;
  result.x+=funcX;
  result.y+=funcY;
  exit(result);
end;

function glModel.closest(funcPointArray:tPointArray):tPointArray;
begin exit(funcPointArray.closestTo(self));end;

function glModel.closest(funcModelArray:glModelArray):glModelArray;overload;
begin exit(funcModelArray.closestTo(self));end;

function glModel.closest(funcTextureArray:glTextureArray):glTextureArray;overload;
begin exit(funcTextureArray.closestTo(self));end;

function glModel.debug(funcClear:boolean = false):glModel;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'glModel'+#13#10+funcMessage+toStr(self));
  exit(self);
end;

function glModel.distanceFrom(funcChar:glChar):extended;
begin exit(sqrt(pow(self.x-funcChar.x,2)+pow(self.y-funcChar.y,2)));end;

function glModel.distanceFrom(funcModel:glModel):extended;overload;
begin exit(sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2)));end;

function glModel.distanceFrom(funcTexture:glTexture):extended;overload;
begin exit(sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2)));end;

function glModel.distanceFrom(funcPoint:tPoint):extended;overload;
begin exit(sqrt(pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2)));end;

function glModel.equals(funcModel:glModel):boolean;
begin exit(compareMem(@self,@funcModel,oglModelSize));end;

function glModel.furthest(funcPointArray:tPointArray):tPointArray;
begin exit(funcPointArray.furthestFrom(self));end;

function glModel.furthest(funcModelArray:glModelArray):glModelArray;overload;
begin exit(funcModelArray.furthestFrom(self));end;

function glModel.furthest(funcTextureArray:glTextureArray):glTextureArray;overload;
begin exit(funcTextureArray.furthestFrom(self));end;

function glModel.isBetween(funcA,funcB:glModel;funcTolerance:int32=100):boolean;
begin exit(self.toPoint().isBetween(funcA.toPoint(),funcB.toPoint(),funcTolerance));end;

function glModel.isBetween(funcA,funcB:tPoint;funcTolerance:int32=100):boolean;overload;
begin exit(self.toPoint().isBetween(funcA,funcB,funcTolerance));end;

function glModel.isInPoly(funcPoint:array of tPoint):boolean;
var
  funcIndex,
    funcIndexMinus:int32;
begin
  funcIndexMinus:=high(funcPoint);
  for funcIndex to high(funcPoint) do
  begin
    if ((funcPoint[funcIndex].y>self.y)<>(funcPoint[funcIndexMinus].y>self.y)) and (self.x<(funcPoint[funcIndexMinus].x-funcPoint[funcIndex].x)*(self.y-funcPoint[funcIndex].y)/(funcPoint[funcIndexMinus].y-funcPoint[funcIndex].y)+funcPoint[funcIndex].x) then
      result:=not result;
    funcIndexMinus:=funcIndex;
  end;
  exit(result);
end;

function glModel.isVisible():boolean;
begin exit(self.toPoint().isVisible());end;

function glModel.randomizePoint(funcX,funcY:int32=0):tPoint;
begin
  result:=self.toPoint();
  result.x+=normalRandom(funcX div 2*-1,funcX div 2);
  result.y+=normalRandom(funcY div 2*-1,funcY div 2);
  exit(result);
end;

function glModel.randomizePointEllipse(funcDiameter:int32):tPoint;
begin exit(self.toPoint().randomizePointEllipse(funcDiameter));end;

function glModel.toPoint():tPoint;
begin exit(tPoint([self.x,self.y]));end;



function glModelArray.closestTo(funcPoint:tPoint):glModelArray;
var
  funcDistance:array of double;
  funcIndex,
    funcLeft,
    funcRight:int32;
  funcTempDistance:double;
  funcTempModel:glModel;
begin
  setLength(funcDistance,length(result:=self));
  for funcIndex to high(result) do
    funcDistance[funcIndex]:=sqrt(pow(result[funcIndex].x-funcPoint.x,2)+pow(result[funcIndex].y-funcPoint.y,2))
  for funcLeft to funcIndex-1 do
    for funcRight:=funcLeft+1 to funcIndex-1 do
    begin
      if (funcTempDistance:=funcDistance[funcLeft])>funcDistance[funcRight] then
      begin
        funcDistance[funcLeft]:=funcDistance[funcRight];
        funcDistance[funcRight]:=funcTempDistance;
        funcTempModel:=result[funcLeft];
        result[funcLeft]:=result[funcRight];
        result[funcRight]:=funcTempModel;
      end;
    end;
  exit(result);
end;

function glModelArray.closestTo(funcModel:glModel):glModelArray;overload;
begin exit(self.closestTo(point(funcModel.x,funcModel.y)));end;

function glModelArray.closestTo(funcTexture:glTexture):glModelArray;overload;
begin exit(self.closestTo(point(funcTexture.x,funcTexture.y)));end;

function glModelArray.debug(funcClear:boolean = false):glModelArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > glModeArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > glModelArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  result:=self;
end;

function glModelArray.equals(funcModels:glModelArray):boolean;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    if not compareMem(@self[funcIndex],@funcModels[funcIndex],oglModelSize) then
      break
    else if funcIndex=high(self) then
      result:=true;
  exit(result);
end;

function glModelArray.first():glModel;
begin
  if length(self) then
    result:=self[0];
  exit(result);
end;

function glModelArray.furthestFrom(funcPoint:tPoint):glModelArray;
var
  funcDistance:array of double;
  funcIndex,
    funcLeft,
    funcRight:int32;
  funcTempDistance:double;
  funcTempModel:glModel;
begin
  setLength(funcDistance,length(result:=self));
  for funcIndex to high(result) do
    funcDistance[funcIndex]:=sqrt(pow(result[funcIndex].x-funcPoint.x,2)+pow(result[funcIndex].y-funcPoint.y,2))
  for funcLeft to funcIndex-1 do
    for funcRight:=funcLeft+1 to funcIndex-1 do
    begin
      if (funcTempDistance:=funcDistance[funcLeft])<funcDistance[funcRight] then
      begin
        funcDistance[funcLeft]:=funcDistance[funcRight];
        funcDistance[funcRight]:=funcTempDistance;
        funcTempModel:=result[funcLeft];
        result[funcLeft]:=result[funcRight];
        result[funcRight]:=funcTempModel;
      end;
    end;
  exit(result);
end;

function glModelArray.furthestFrom(funcModel:glModel):glModelArray;overload;
begin exit(self.furthestFrom(point(funcModel.x,funcModel.y)));end;

function glModelArray.furthestFrom(funcTexture:glTexture):glModelArray;overload;
begin exit(self.furthestFrom(point(funcTexture.x,funcTexture.y)));end;

function glModelArray.getModels(funcID:array of uInt32):glModelArray;
var
  funcIDIndex,
    funcResultIndex:int32;
  funcPointer:^glModel;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
      begin
        result[funcResultIndex]:=funcPointer^;
        funcResultIndex+=1;
        break;
      end;
    funcPointer+=oglModelSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glModelArray.getModels(funcID:array of int32):glModelArray;overload;
begin exit(self.getModels(tCardinalArray(funcID)));end;

function glModelArray.getModels(funcID:uInt32):glModelArray;overload;
begin exit(self.getModels(tCardinalArray([funcID])));end;

function glModelArray.getModels(funcID:array of uInt32;funcTID:array of int32):glModelArray;overload;
var
  funcIDIndex,
    funcResultIndex,
    funcTIDIndex:int32;
  funcPointer:^glModel;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
        for funcTIDIndex:=0 to high(funcTID) do
          if funcPointer^.tid=funcTID[funcTIDIndex] then
            begin
              result[funcResultIndex]:=funcPointer^;
              funcResultIndex+=1;
              funcIDIndex:=high(funcID);
              break;
            end;
    funcPointer+=oglModelSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glModelArray.getModels(funcID:array of int32;funcTID:int32):glModelArray;overload;
begin exit(self.getModels(tCardinalArray(funcID),[funcTID]));end;

function glModelArray.getModels(funcID:uInt32;funcTID:int32):glModelArray;overload;
begin exit(self.getModels(tCardinalArray([funcID]),[funcTID]));end;

function glModelArray.getModels(funcID:array of uInt32;funcTID:array of int32;funcBounds:array of tBox):glModelArray;overload;
var
  funcBoundsIndex,
    funcIDIndex,
    funcResultIndex,
    funcTIDIndex:int32;
  funcPointer:^glModel;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
        for funcTIDIndex:=0 to high(funcTID) do
          if funcPointer^.tid=funcTID[funcTIDIndex] then
            for funcBoundsIndex:=0 to high(funcBounds) do
              if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
              begin
                result[funcResultIndex]:=funcPointer^;
                funcResultIndex+=1;
                funcIDIndex:=high(funcID);
                funcTIDIndex:=high(funcTID);
                break;
              end;
    funcPointer+=oglModelSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glModelArray.getModels(funcID:array of int32;funcTID:int32;funcBounds:tBox):glModelArray;overload;
begin exit(self.getModels(tCardinalArray(funcID),[funcTID],[funcBounds]));end;

function glModelArray.getModels(funcID:uInt32;funcTID:int32;funcBounds:tBox):glModelArray;overload;
begin exit(self.getModels(tCardinalArray([funcID]),[funcTID],[funcBounds]));end;

function glModelArray.getModels(funcID:array of uInt32;funcBounds:array of tBox):glModelArray;overload;
var
  funcBoundsIndex,
    funcIDIndex,
    funcResultIndex:int32;
  funcPointer:^glModel;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
        for funcBoundsIndex:=0 to high(funcBounds) do
          if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
          begin
            result[funcResultIndex]:=funcPointer^;
            funcResultIndex+=1;
            funcIDIndex:=high(funcID);
            break;
          end;
    funcPointer+=oglModelSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glModelArray.getModels(funcID:array of int32;funcBounds:tBox):glModelArray;overload;
begin exit(self.getModels(tCardinalArray(funcID),[funcBounds]));end;

function glModelArray.getModels(funcID:uInt32;funcBounds:tBox):glModelArray;overload;
begin exit(self.getModels(tCardinalArray([funcID]),[funcBounds]));end;

function glModelArray.getModels(funcBounds:array of tBox):glModelArray;overload;
var
  funcBoundsIndex,
    funcResultIndex:int32;
  funcPointer:^glModel;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcBoundsIndex:=0 to high(funcBounds) do
      if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
      begin
        result[funcResultIndex]:=funcPointer^;
        funcResultIndex+=1;
        break;
      end;
    funcPointer+=oglModelSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glModelArray.getModels(funcBounds:tBox):glModelArray;overload;
begin exit(self.getModels([funcBounds]))end;

function glModelArray.getVisible():glModelArray;
var
  funcBounds:tBoxArray;
  funcBoundsIndex,
    funcResultIndex,
    funcSelfIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  setLength(result,length(self));
  funcPointer:=glTextures(funcPointerSize);
  setLength(funcBounds,funcPointerSize);
  for 0 to funcPointerSize-8 do
  begin
    if (funcPointer^.id=3060) and ((funcPointer+5*oglTextureSize)^.id=28550)then
    begin
      funcBounds[funcBoundsIndex]:=tBox([funcPointer^.bounds.x1,funcPointer^.bounds.y1,(funcPointer+5*oglTextureSize)^.bounds.x2,(funcPointer+5*oglTextureSize)^.bounds.y2]);
      funcBoundsIndex+=1;
    end
    else if (funcPointer^.id=4080) and ((funcPointer+7*oglTextureSize)^.id=16320) then
    begin
      funcBounds[funcBoundsIndex]:=tBox([funcPointer^.bounds.x1,funcPointer^.bounds.y1,(funcPointer+7*oglTextureSize)^.bounds.x2,(funcPointer+7*oglTextureSize)^.bounds.y2]);
      funcBoundsIndex+=1;
    end ;
    funcPointer+=oglTextureSize;
  end
  setLength(funcBounds,funcBoundsIndex);
  for funcSelfIndex to high(self) do
    for funcBoundsIndex:=0 to high(funcBounds) do
    begin
      if pointInBox(self[funcSelfIndex].toPoint(),funcBounds[funcBoundsIndex]) then
        break
      else if funcBoundsIndex=high(funcBounds) then
      begin
        result[funcResultIndex]:=self[funcSelfIndex];
        funcResultIndex+=1;
      end;
    end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glModelArray.indexes():integer;
begin exit(length(self));end;

function glModelArray.isEmpty():boolean;
  begin exit(pointer(self)=nil);end;

function glModelArray.last():glModel;
begin
  if length(self) then
    result:=self[high(self)];
  exit(result);
end;

function glModelArray.maxIndex():int32;
begin exit(high(self));end;

function glModelArray.minIndex():int32;
begin exit(low(self));end;

function glModelArray.reverse():glModelArray;
var
  funcIndex:int32;
  funcPointer:^glModel;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=oglModelSize;
  end;
  exit(result);
end;

function glModelArray.toPointArray():tPointArray;
var
  funcIndex:int32;
begin
  setLength(result,length(self));
  for funcIndex to self.maxIndex() do
    result[funcIndex]:=[self[funcIndex].x,self[funcIndex].y];
  exit(result);
end;



function glTexture.adjustPosition(funcX,funcY:integer=0):glTexture;
begin
  result:=self;
  result.x:=result.x+funcX;
  result.y:=result.y+funcY;
  result.bounds.x1:=result.bounds.x1+funcX;
  result.bounds.x1:=result.bounds.y1+funcY;
  result.bounds.x2:=result.bounds.x2+funcX;
  result.bounds.y2:=result.bounds.y2+funcY;
  exit(result);
end;

function glTexture.closest(funcPointArray:tPointArray):tPointArray;
begin exit(funcPointArray.closestTo(self));end;

function glTexture.closest(funcModelArray:glModelArray):glModelArray;overload;
begin exit(funcModelArray.closestTo(self));end;

function glTexture.closest(funcTextureArray:glTextureArray):glTextureArray;overload;
begin exit(funcTextureArray.closestTo(self));end;

function glTexture.debug(funcClear:boolean = false):glTexture;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'glTexture'+#13#10+funcMessage+toStr(self));
  exit(self);
end;

function glTexture.distanceFrom(funcPoint:tPoint):extended;
begin exit(sqrt(pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2)));end;

function glTexture.distanceFrom(funcModel:glModel):extended;overload;
begin exit(sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2)));end;

function glTexture.distanceFrom(funcTexture:glTexture):extended;overload;
begin exit(sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2)));end;

function glTexture.equals(funcTexture:glTexture):boolean;
begin exit(compareMem(@self,@funcTexture,oglTextureSize));end;

function glTexture.furthest(funcPointArray:tPointArray):tPointArray;
begin exit(funcPointArray.furthestFrom(self));end;

function glTexture.furthest(funcModelArray:glModelArray):glModelArray;overload;
begin exit(funcModelArray.furthestFrom(self));end;

function glTexture.furthest(funcTextureArray:glTextureArray):glTextureArray;overload;
begin exit(funcTextureArray.furthestFrom(self));end;

function glTexture.isInPoly(funcPoint:array of tPoint):boolean;
var
  funcIndex,
    funcIndexMinus:int32=0;
begin
  funcIndexMinus:=high(funcPoint);
  for funcIndex to high(funcPoint) do
  begin
    if ((funcPoint[funcIndex].y>self.y)<>(funcPoint[funcIndexMinus].y>self.y)) and (self.x<(funcPoint[funcIndexMinus].x-funcPoint[funcIndex].x)*(self.y-funcPoint[funcIndex].y)/(funcPoint[funcIndexMinus].y-funcPoint[funcIndex].y)+funcPoint[funcIndex].x) then
      result:=not result;
    funcIndexMinus:=funcIndex;
  end;
  exit(result);
end;

function glTexture.isVisible():boolean;
  var
    funcSelfPoint:tPoint;
  begin
    funcSelfPoint:=[self.x,self.y];
    exit(result:=funcSelfPoint.isVisible());
  end;

function glTexture.randomizePoint(funcX,funcY:int32=0):tPoint;
begin
  result:=self.toPoint();
  result.x+=normalRandom(funcX div 2*-1,funcX div 2);
  result.y+=normalRandom(funcY div 2*-1,funcY div 2);
  exit(result);
end;

function glTexture.randomizePointEllipse(funcDiameter:int32):tPoint;
begin exit(self.toPoint().randomizePointEllipse(funcDiameter));end;

function glTexture.toPoint():tPoint;
begin exit(tPoint([self.x,self.y]));end;

function glTexture.normalizePoint():tPoint;
begin
  exit(point(normalRandom(self.bounds.x1,self.bounds.x2),normalRandom(self.bounds.y1,self.bounds.y2)));
end;

function glTextureArray.closestTo(funcPoint:tPoint):glTextureArray;
var
  funcDistance:array of double;
  funcIndex,
    funcLeft,
    funcRight:int32;
  funcTempDistance:double;
  funcTempTexture:glTexture;
begin
  setLength(funcDistance,length(result:=self));
  for funcIndex to high(result) do
    funcDistance[funcIndex]:=sqrt(pow(result[funcIndex].x-funcPoint.x,2)+pow(result[funcIndex].y-funcPoint.y,2))
  for funcLeft to funcIndex-1 do
    for funcRight:=funcLeft+1 to funcIndex-1 do
    begin
      if (funcTempDistance:=funcDistance[funcLeft])>funcDistance[funcRight] then
      begin
        funcDistance[funcLeft]:=funcDistance[funcRight];
        funcDistance[funcRight]:=funcTempDistance;
        funcTempTexture:=result[funcLeft];
        result[funcLeft]:=result[funcRight];
        result[funcRight]:=funcTempTexture;
      end;
    end;
  exit(result);
end;

function glTextureArray.closestTo(funcModel:glModel):glTextureArray;overload;
begin exit(self.closestTo(point(funcModel.x,funcModel.y)));end;

function glTextureArray.closestTo(funcTexture:glTexture):glTextureArray;overload;
begin exit(self.closestTo(point(funcTexture.x,funcTexture.y)));end;

function glTextureArray.debug(funcClear:boolean = false):glTextureArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > glTextureArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > glTextureArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;

function glTextureArray.equals(funcTextures:glTextureArray):boolean;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    if not compareMem(@self[funcIndex],@funcTextures[funcIndex],oglTextureSize) then
      break
    else if funcIndex=high(self) then
      result:=true;
  exit(result);
end;

function glTextureArray.first():glTexture;
begin
  if length(self) then
    result:=self[0];
  exit(result);
end;

function glTextureArray.furthestFrom(funcPoint:tPoint):glTextureArray;
var
  funcDistance:array of double;
  funcIndex,
    funcLeft,
    funcRight:int32;
  funcTempDistance:double;
  funcTempTexture:glTexture;
begin
  setLength(funcDistance,length(result:=self));
  for funcIndex to high(result) do
    funcDistance[funcIndex]:=sqrt(pow(result[funcIndex].x-funcPoint.x,2)+pow(result[funcIndex].y-funcPoint.y,2))
  for funcLeft to funcIndex-1 do
    for funcRight:=funcLeft+1 to funcIndex-1 do
    begin
      if (funcTempDistance:=funcDistance[funcLeft])>funcDistance[funcRight] then
      begin
        funcDistance[funcLeft]:=funcDistance[funcRight];
        funcDistance[funcRight]:=funcTempDistance;
        funcTempTexture:=result[funcLeft];
        result[funcLeft]:=result[funcRight];
        result[funcRight]:=funcTempTexture;
      end;
    end;
  exit(result);
end;

function glTextureArray.furthestFrom(funcModel:glModel):glTextureArray;overload;
begin exit(self.furthestFrom(point(funcModel.x,funcModel.y)));end;

function glTextureArray.furthestFrom(funcTexture:glTexture):glTextureArray;overload;
begin exit(self.furthestFrom(point(funcTexture.x,funcTexture.y)));end;

function glTextureArray.getTextures(funcID:array of int32):glTextureArray;
var
  funcIDIndex,
    funcResultIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
      begin
        result[funcResultIndex]:=funcPointer^;
        funcResultIndex+=1;
        break;
      end;
    funcPointer+=oglTextureSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glTextureArray.getTextures(funcID:int32):glTextureArray;overload;
begin exit(self.getTextures([funcID]));end;

function glTextureArray.getTextures(funcID,funcColourID:array of int32):glTextureArray;overload;
var
  funcColourIDIndex,
    funcIDIndex,
    funcResultIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
        for funcColourIDIndex:=0 to high(funcColourID) do
          if similarColors(funcPointer^.colourID,funcColourID[funcColourIDIndex],oglColourTolerance) then
          begin
            result[funcResultIndex]:=funcPointer^;
            funcResultIndex+=1;
            funcIDIndex:=high(funcID);
            break;
          end;
    funcPointer+=oglTextureSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glTextureArray.getTextures(funcID,funcColourID:int32):glTextureArray;overload;
begin exit(self.getTextures([funcID],[funcColourID]));end;

function glTextureArray.getTextures(funcID,funcColourID:array of int32;funcBounds:array of tBox):glTextureArray;overload;
var
  funcBoundsIndex,
    funcColourIDIndex,
    funcIDIndex,
    funcResultIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
        for funcColourIDIndex:=0 to high(funcColourID) do
          if similarColors(funcPointer^.colourID,funcColourID[funcColourIDIndex],oglColourTolerance) then
            for funcBoundsIndex:=0 to high(funcBounds) do
              if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
              begin
                result[funcResultIndex]:=funcPointer^;
                funcResultIndex+=1;
                funcIDIndex:=high(funcID);
                funcColourIDIndex:=high(funcColourID);
                break;
              end;
    funcPointer+=oglTextureSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glTextureArray.getTextures(funcID,funcColour:int32;funcBounds:tBox):glTextureArray;overload;
begin exit(self.getTextures([funcID],[funcColour],[funcBounds]));end;

function glTextureArray.getTextures(funcID:array of int32;funcBounds:array of tBox):glTextureArray;overload;
var
  funcBoundsIndex,
    funcIDIndex,
    funcResultIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcIDIndex:=0 to high(funcID) do
      if funcPointer^.id=funcID[funcIDIndex] then
        for funcBoundsIndex to high(funcBounds) do
          if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
          begin
            result[funcResultIndex]:=funcPointer^;
            funcResultIndex+=1;
            funcIDIndex:=high(funcID);
            break;
          end;
    funcPointer+=oglTextureSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glTextureArray.getTextures(funcID:int32;funcBounds:tBox):glTextureArray;overload;
begin exit(self.getTextures([funcID],[funcBounds]));end;

function glTextureArray.getTextures(funcBounds:array of tBox):glTextureArray;overload;
var
  funcBoundsIndex,
    funcResultIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for 0 to high(self) do
  begin
    for funcBoundsIndex:=0 to high(funcBounds) do
      if pointInBox([funcPointer^.x,funcPointer^.y],funcBounds[funcBoundsIndex]) then
      begin
        result[funcResultIndex]:=funcPointer^;
        funcResultIndex+=1;
        break;
      end;
    funcPointer+=oglTextureSize;
  end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function glTextureArray.getTextures(funcBounds:tBox):glTextureArray;overload;
begin exit(self.getTextures([funcBounds]));end;

function glTextureArray.indexes():integer;
begin exit(length(self));end;

function glTextureArray.isEmpty():boolean;
begin exit(pointer(self)=nil);end;

function glTextureArray.last():glTexture;
begin
  if length(self) then
    result:=self[high(self)];
  exit(result);
end;

function glTextureArray.maxIndex():int32;
begin exit(high(self));end;

function glTextureArray.minIndex():int32;
begin exit(low(self));end;

function glTextureArray.reverse():glTextureArray;
var
  funcIndex:int32;
  funcPointer:^glTexture;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=oglTextureSize;
  end;
  exit(result);
end;

function glTextureArray.toPointArray():tPointArray;
var
  funcIndex:int32;
begin
  setLength(result,self.indexes());
  for funcIndex to self.maxIndex() do
    result[funcIndex]:=[self[funcIndex].x,self[funcIndex].y];
  exit(result);
end;



function integer.debug(funcClear:boolean = false):integer;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'integer'+#13#10+funcMessage+toStr(self));
  exit(self);
end;

function integer.isBetween(funcA,funcB:integer):boolean;
begin exit((self>=min(funcA,funcB)) and (self<=max(funcA,funcB)));end;



function tBoolArray.debug(funcClear:boolean = false):tBoolArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tBoolArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tBoolArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;



function tBoolArray.equals(funcBools:tBoolArray):boolean;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    if not compareMem(@self[funcIndex],@funcBools[funcIndex],1) then
      break
    else if funcIndex=high(self) then
      result:=true;
  exit(result);
end;

function tBoolArray.reverse():tBoolArray;
var
  funcIndex:int32;
  funcPointer:^boolean;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=sizeOf(boolean);
  end;
  exit(result);
end;

function tBox.adjustPosition(funcX1,funcY1,funcX2,funcY2:integer):tBox;
begin
  result:=self;
  result.x1:=result.x1+funcX1;
  result.y1:=result.y1+funcY1;
  result.x2:=result.x2+funcX2;
  result.y2:=result.y2+funcY2;
  exit(result);
end;

function tBox.debug(funcClear:boolean = false):tBox;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'tBox'+#13#10+funcMessage+toStr(self));
  exit(self);
end;

function tBox.equals(funcBox:tBox):boolean;  {$IFDEF SRLCompatibility} override; {$ENDIF}
begin exit(compareMem(@self,@funcBox,sizeOf(tBox)));end;

function tBox.normalizePoint():tPoint;
begin exit(tPoint([normalRandom(self.x1,self.x2),normalRandom(self.y1,self.y2)]));end;

function tBoxArray.debug(funcClear:boolean = false):tBoxArray;
var
  funcIndex:int32=0;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tBoxArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tBoxArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;

function tBoxArray.indexes():integer;
begin exit(length(self));end;

function tBoxArray.isEmpty():boolean;
begin exit(pointer(self)=nil);end;

function tBoxArray.maxIndex():int32;
begin exit(high(self));end;

function tBoxArray.minIndex():int32;
begin exit(low(self));end;

function tBoxArray.reverse():tBoxArray;
var
  funcIndex:int32;
  funcPointer:^tBox;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=sizeOf(tBox);
  end;
  exit(result);
end;

function tCardinalArray.contains(funcID:uInt32):boolean;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    if self[funcIndex]=funcID then
    begin
      result:=true;
      break;
    end;
  exit(result);
end;

function tCardinalArray.debug(funcClear:boolean = false):tCardinalArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tCardinalArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tCardinalArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;

function tCardinalArray.indexes():integer;
begin exit(length(self));end;

function tCardinalArray.isEmpty():boolean;
begin exit(pointer(self)=nil);end;

function tCardinalArray.maxIndex():int32;
begin exit(high(self));end;

function tCardinalArray.minIndex():int32;
begin exit(low(self));end;



{$IFNDEF SRLCompatibility}
function tCountDown.isFinished():boolean;
  begin exit(getSystemTime()>=self);end;

function tCountDown.setTime(funcTime:uInt32):uInt32;
  begin exit(self:=getSystemTime()+funcTime);end;

function tCountDown.timeRemaining():uInt32;
  begin
    if not self.isFinished() then
      exit(self-getSystemTime());
  end;
{$ENDIF}



function tExtendedArray.debug(funcClear:boolean = false):tExtendedArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tExtendedArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tExtendedArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;



function tIntegerArray.contains(funcID:int32):boolean;
var
  funcIndex:int32;
begin
  for funcIndex to high(self) do
    if self[funcIndex]=funcID then
    begin
      result:=true;
      break;
    end;
  exit(result);
end;

function tIntegerArray.debug(funcClear:boolean = false):tIntegerArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tIntegerArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tIntegerArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;

function tIntegerArray.indexes():integer;
begin exit(length(self));end;

function tIntegerArray.isEmpty():boolean;
begin exit(pointer(self)=nil);end;

function tIntegerArray.maxIndex():int32;
begin exit(high(self));end;

function tIntegerArray.minIndex():int32;
begin exit(low(self));end;

function tIntegerArray.reverse():tIntegerArray;
var
  funcIndex:int32;
  funcPointer:^integer;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=sizeOf(integer);
  end;
  exit(result);
end;

function tPoint.adjustPosition(funcX,funcY:integer=0):tPoint;
begin exit(tPoint([self.x+funcX,self.y+funcY]));end;

function tPoint.closest(funcPointArray:tPointArray):tPointArray;
begin exit(funcPointArray.closestTo(self));end;

function tPoint.closest(funcModelArray:glModelArray):glModelArray;overload;
begin exit(funcModelArray.closestTo(self));end;

function tPoint.closest(funcTextureArray:glTextureArray):glTextureArray;overload;
begin exit(funcTextureArray.closestTo(self));end;

function tPoint.debug(funcClear:boolean = false):tPoint;
var
  funcMessage:string;
begin
  if funcClear then
    clearDebug();
  writeLN((funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > ')+'tPoint'+#13#10+funcMessage+toStr(self));
  exit(self);
end;

function tPoint.distanceFrom(funcPoint:tPoint):extended;
begin exit(sqrt(pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2)));end;

function tPoint.distanceFrom(funcModel:glModel):extended;overload;
begin exit(sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2)));end;

function tPoint.distanceFrom(funcTexture:glTexture):extended;overload;
begin exit(sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2)));end;

function tPoint.equals(funcBox:tPoint):boolean; {$IFDEF SRLCompatibility} override; {$ENDIF}
begin exit(compareMem(@self,@funcBox,8));end;

function tPoint.furthest(funcPointArray:tPointArray):tPointArray;
begin exit(funcPointArray.furthestFrom(self));end;

function tPoint.furthest(funcModelArray:glModelArray):glModelArray;overload;
begin exit(funcModelArray.furthestFrom(self));end;

function tPoint.furthest(funcTextureArray:glTextureArray):glTextureArray;overload;
begin exit(funcTextureArray.furthestFrom(self));end;

function tPoint.isBetween(funcA,funcB:glModel;funcTolerance:int32=100):boolean;
begin exit(self.isBetween(funcA.toPoint(),funcB.toPoint(),funcTolerance));end;

function tPoint.isBetween(funcA,funcB:tPoint;funcTolerance:int32=100):boolean;overload;
var
  funcAngle,
    funcAngleNegative,
    funcCos,
    funcCosNegative,
    funcSin,
    funcSinNegative:double;
  funcPoint:array[0..3] of tPoint;
begin
  funcAngle:=arcTan2(funcB.y-funcA.y,funcB.x-funcA.x)+1.5707963267948966192313216916398;
  funcAngleNegative:=funcAngle-1.5707963267948966192313216916398*2;
  funcCos:=cos(funcAngle);
  funcCosNegative:=cos(funcAngleNegative);
  funcSin:=sin(funcAngle);
  funcSinNegative:=sin(funcAngleNegative);
  funcTolerance:=round(funcTolerance/2);
  funcPoint[0]:=[round(funcA.x+funcTolerance*funcCos),round(funcA.y+funcTolerance*funcSin)];
  funcPoint[1]:=[round(funcA.x+funcTolerance*funcCosNegative),round(funcA.y+funcTolerance*funcSinNegative)];
  funcPoint[2]:=[round(funcB.x+funcTolerance*funcCosNegative),round(funcB.y+funcTolerance*funcSinNegative)];
  funcPoint[3]:=[round(funcB.x+funcTolerance*funcCos),round(funcB.y+funcTolerance*funcSin)];
  exit(result:=self.isInPoly(funcPoint));
end;

function tPoint.isInPoly(funcPoint:array of tPoint):boolean;
var
  funcIndex,
    funcIndexMinus:int32;
begin
  funcIndexMinus:=high(funcPoint);
  for funcIndex to high(funcPoint) do
    begin
      if ((funcPoint[funcIndex].y>self.y)<>(funcPoint[funcIndexMinus].y>self.y)) and (self.x<(funcPoint[funcIndexMinus].x-funcPoint[funcIndex].x)*(self.y-funcPoint[funcIndex].y)/(funcPoint[funcIndexMinus].y-funcPoint[funcIndex].y)+funcPoint[funcIndex].x) then
        result:=not result;
      funcIndexMinus:=funcIndex;
    end;
  exit(result);
end;

function tPoint.isVisible():boolean;
var
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  result:=true;
  funcPointer:=glTextures(funcPointerSize);
  for 0 to funcPointerSize-8 do
  begin
    if (funcPointer^.id=3060) and ((funcPointer+5*oglTextureSize)^.id=28550)then
    begin
      if pointInBox(self,[funcPointer^.bounds.x1,funcPointer^.bounds.y1,(funcPointer+5*oglTextureSize)^.bounds.x2,(funcPointer+5*oglTextureSize)^.bounds.y2]) then
      begin
        result:=false;
        break;
      end;
    end
    else if (funcPointer^.id=4080) and ((funcPointer+7*oglTextureSize)^.id=16320) then
    begin
      if pointInBox(self,[funcPointer^.bounds.x1,funcPointer^.bounds.y1,(funcPointer+7*oglTextureSize)^.bounds.x2,(funcPointer+7*oglTextureSize)^.bounds.y2]) then
      begin
        result:=false;
        break;
      end;
    end
    funcPointer+=oglTextureSize;
  end
  exit(result);
end;

function tPoint.randomizePoint(funcX,funcY:int32=0):tPoint;
begin
  result:=self;
  result.x+=normalRandom(funcX div 2*-1,funcX div 2);
  result.y+=normalRandom(funcY div 2*-1,funcY div 2);
  exit(result);
end;

function tPoint.randomizePointEllipse(funcDiameter:int32):tPoint;
var
  funcAngle,
    funcRadius,
    funcRandom:double;
begin
  funcAngle:=random()*6.283185307179586476925286766559;
  funcRadius:=funcDiameter*abs(normalRandomE()-0.5);
  result:=[self.x+round(funcRadius*cos(funcAngle)),self.y+round(funcRadius*sin(funcAngle))];
end;

function tPointArray.closestTo(funcPoint:tPoint):tPointArray;
begin
  result:=self;
  sortTPAFrom(result,funcPoint);
  exit(result);
end;

function tPointArray.closestTo(funcModel:glModel):tPointArray;overload;
begin
  result:=self;
  sortTPAFrom(result,funcModel.toPoint());
  exit(result);
end;

function tPointArray.closestTo(funcTexture:glTexture):tPointArray;overload;
begin
  result:=self;
  sortTPAFrom(result,funcTexture.toPoint());
  exit(result);
end;

function tPointArray.debug(funcClear:boolean = false):tPointArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tPointArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tPointArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;

function tPointArray.furthestFrom(funcPoint:tPoint):tPointArray;
begin
  result:=self;
  sortTPAFrom(result,funcPoint);
  result:=result.reverse();
  exit(result);
end;

function tPointArray.furthestFrom(funcModel:glModel):tPointArray;overload;
begin
  result:=self;
  sortTPAFrom(result,funcModel.toPoint());
  result:=result.reverse();
  exit(result);
end;

function tPointArray.furthestFrom(funcTexture:glTexture):tPointArray;overload;
begin
  result:=self;
  sortTPAFrom(result,funcTexture.toPoint());
  result:=result.reverse();
  exit(result);
end;

function tPointArray.getVisible():tPointArray;
var
  funcBounds:tBoxArray;
  funcBoundsIndex,
    funcResultIndex,
    funcSelfIndex:int32;
  funcPointer:^glTexture;
  funcPointerSize:uInt32;
begin
  setLength(result,length(self));
  funcPointer:=glTextures(funcPointerSize);
  setLength(funcBounds,funcPointerSize);
  for 0 to funcPointerSize-8 do
  begin
    if (funcPointer^.id=3060) and ((funcPointer+5*oglTextureSize)^.id=28550)then
    begin
      funcBounds[funcBoundsIndex]:=tBox([funcPointer^.bounds.x1,funcPointer^.bounds.y1,(funcPointer+5*oglTextureSize)^.bounds.x2,(funcPointer+5*oglTextureSize)^.bounds.y2]);
      funcBoundsIndex+=1;
    end
    else if (funcPointer^.id=4080) and ((funcPointer+7*oglTextureSize)^.id=16320) then
    begin
      funcBounds[funcBoundsIndex]:=tBox([funcPointer^.bounds.x1,funcPointer^.bounds.y1,(funcPointer+7*oglTextureSize)^.bounds.x2,(funcPointer+7*oglTextureSize)^.bounds.y2]);
      funcBoundsIndex+=1;
    end ;
    funcPointer+=oglTextureSize;
  end
  for funcSelfIndex to high(self) do
    for funcBoundsIndex:=0 to high(funcBounds) do
    begin
      if pointInBox(self[funcSelfIndex],funcBounds[funcBoundsIndex]) then
        break
      else if funcBoundsIndex=high(funcBounds) then
      begin
        result[funcResultIndex]:=self[funcSelfIndex];
        funcResultIndex+=1;
      end;
    end;
  setLength(result,funcResultIndex);
  exit(result);
end;

function tPointArray.indexes():integer;
begin exit(length(self));end;

function tPointArray.isEmpty():boolean;
begin exit(pointer(self)=nil);end;

function tPointArray.maxIndex():int32;
begin exit(high(self));end;

function tPointArray.minIndex():int32;
begin exit(low(self));end;

function tPointArray.reverse():tPointArray;
var
  funcIndex:int32;
  funcPointer:^tPoint;
begin
  funcPointer:=pointer(self);
  setLength(result,length(self));
  for funcIndex:=high(self) downTo 0 do
  begin
    result[funcIndex]:=funcPointer^;
    funcPointer+=sizeOf(tPoint);
  end;
  exit(result);
end;



function tStringArray.debug(funcClear:boolean = false):tStringArray;
var
  funcIndex:int32;
  funcMessage,
    funcString:string;
begin
  case length(self) of
    false:funcString:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tStringArray[]';
    true:funcString:=(funcMessage:=formatDateTime('tt',time())+' | '+ogl.getScriptName()+' > tStringArray[')+'0..'+toStr(high(self))+']';
  end;
  for funcIndex to high(self) do
    funcString:=funcString+#13#10+funcMessage+toStr(funcIndex)+'] > '+toStr(self[funcIndex]);
  if funcClear then
    clearDebug();
  writeLN(funcString);
  exit(self);
end;

function tStringArray.equals(funcStrings:tStringArray):boolean;
var
  funcIndex:int32=0;
begin
  for funcIndex to high(self) do
    if self[funcIndex]<>funcStrings[funcIndex] then
      break
    else if funcIndex=high(self) then
      result:=true;
  exit(result);
end;

function tStringArray.indexes():integer;
begin exit(length(self));end;

function tStringArray.isEmpty():boolean;
begin exit(pointer(self)=nil);end;

function tStringArray.maxIndex():int32;
begin exit(high(self));end;

function tStringArray.minIndex():int32;
begin exit(low(self));end;

function tStringArray.reverse():tStringArray;
var
  funcIndex,
    funcLength,
    funcMaxIndex:uInt32;
begin
  if (funcLength:=length(self)) then
  begin
    setLength(result,funcLength);
    for (funcIndex:=0) to (funcMaxIndex:=high(self)) do
      result[funcMaxIndex-funcIndex]:=self[funcIndex];
  end;
  exit(result);
end;




function pointer.length():uInt32;
type funcPointer=^uInt32;
begin
  result:=(funcPointer(self)-4)^+1;
end;
