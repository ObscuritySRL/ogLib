function ansiString.parseInt():int32;
  var
    funcIndex,
      funcLength:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        for funcIndex:=1 to funcLength do
          case self[funcIndex] of
            '0'..'9':result:=strToInt(+self[funcIndex])+result*10;
          end;
      end;
    exit(result);
  end;

function ansiString.reverse():ansiString;
  var
    funcIndex,
      funcLength:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        for funcIndex:=0 to funcLength-1 do
          result:=result+self[funcLength-funcIndex];
      end;
    exit(result);
  end;

function countDown.setTime(funcTime:uInt32):uInt32;
  begin
    __:=getSystemTime()+funcTime;
    exit(result:=funcTime);
  end;

function countDown.timeRemaining():uInt32;
  begin
    if (not self.isFinished()) then
      exit(result:=__-getSystemTime());
  end;

function countDown.isFinished():boolean;
  begin exit(result:=getSystemTime()>=__);end;

function glChar.adjustPosition(funcX,funcY:integer=0):glChar;
  begin result:=[self.textureID,self.colour,self.x+funcX,self.y+funcX,self.letter,self.shadow,[self.translate[0]+funcX,self.translate[1]+funcY,self.translate[2]]];end;

function glCharArray.contains(funcString:ansiString):boolean;
  var
    funcChar:int32;
    funcIntegerArray:array of integer;
    funcIntegerArrayIndex,
      funcLength,
      funcMatch,
      funcPointerIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        funcString:=replace(lowercase(funcString),' ','',[0]);
        setLength(funcIntegerArray,funcLength:=length(funcString));
        for funcIntegerArrayIndex to funcLength-1 do
          funcIntegerArray[funcIntegerArrayIndex]:=ord(funcString[funcIntegerArrayIndex+1]);
        for funcPointerIndex to high(self)-funcLength do
          begin
            case funcChar:=(funcPointer+16)^ of
              65..90:funcChar:=funcChar+32;
            end;
            if funcChar=funcIntegerArray[funcMatch] then
              begin
                funcMatch:=funcMatch+1;
                if funcMatch=funcLength then
                  begin
                    result:=true;
                    break;
                  end;
              end
            else
              funcMatch:=0;
            funcPointer:=funcPointer+48;
          end;
      end;
    exit(result);
  end;


function glCharArray.getChars(funcTextureID:array of uInt32):glCharArray;overload;
  var
    funcPointer:pointer;
    funcPointerIndex,
      funcPointerSize,
      funcResultIndex,
      funcTextureIDIndex:uInt32=0;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcTextureIDIndex:=0 to high(funcTextureID) do
              if funcPointer^=funcTextureID[funcTextureIDIndex] then
                begin
                  result[funcResultIndex]:=glChar(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                  break;
                end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glCharArray.getChars(funcTextureID:uInt32):glCharArray;overload;
  begin exit(result:=self.getChars(tCardinalArray([funcTextureID])));end;

function glCharArray.getChars(funcTextureID:array of uInt32;funcColour:array of int32):glCharArray;overload;
  var
    funcColourIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex,
      funcTextureIDIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcTextureIDIndex:=0 to high(funcTextureID) do
              if funcPointer^=funcTextureID[funcTextureIDIndex] then
                for funcColourIndex:=0 to high(funcColour) do
                  if similarColors((funcPointer+4)^,funcColour[funcColourIndex],oglColourTolerance) then
                    begin
                      result[funcResultIndex]:=glChar(funcPointer^);
                      funcResultIndex:=funcResultIndex+1;
                      funcTextureIDIndex:=high(funcTextureID);
                      break;
                    end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end

function glCharArray.getChars(funcTextureID:uInt32;funcColour:int32):glCharArray;overload;
  begin exit(result:=self.getChars(tCardinalArray([funcTextureID]),[funcColour]));end;

function glCharArray.getChars(funcTextureID:array of uInt32;funcColour:array of int32;funcBounds:array of tBox):glCharArray;overload;
  var
    funcBoundsIndex,
      funcColourIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex,
      funcTextureIDIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcTextureIDIndex:=0 to high(funcTextureID) do
              if funcPointer^=funcTextureID[funcTextureIDIndex] then
                for funcColourIndex:=0 to high(funcColourIndex) do
                  if similarColors((funcPointer+4)^,funcColour[funcColourIndex],oglColourTolerance) then
                    for funcBoundsIndex:=0 to high(funcBounds) do
                      if pointInBox([(funcPointer+8)^,(funcPointer+12)^],funcBounds[funcBoundsIndex]) then
                        begin
                          result[funcResultIndex]:=glChar(funcPointer^);
                          funcResultIndex:=funcResultIndex+1;
                          funcTextureIDIndex:=high(funcTextureID);
                          funcColourIndex:=high(funcColour);
                          break;
                        end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end

function glCharArray.getChars(funcTextureID:uInt32;funcColour:int32;funcBounds:tBox):glCharArray;overload;
  begin exit(result:=self.getChars(tCardinalArray([funcTextureID]),[funcColour],[funcBounds]));end;

function glCharArray.getChars(funcTextureID:array of uInt32;funcBounds:array of tBox):glCharArray;overload;
  var
    funcBoundsIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex,
      funcTextureIDIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcTextureIDIndex:=0 to high(funcTextureID) do
              if funcPointer^=funcTextureID[funcTextureIDIndex] then
                for funcBoundsIndex:=0 to high(funcBounds) do
                  if pointInBox([(funcPointer+8)^,(funcPointer+12)^],funcBounds[funcBoundsIndex]) then
                    begin
                      result[funcResultIndex]:=glChar(funcPointer^);
                      funcResultIndex:=funcResultIndex+1;
                      funcTextureIDIndex:=high(funcTextureID);
                      break;
                    end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glCharArray.getChars(funcTextureID:uInt32;funcBounds:tBox):glCharArray;overload;
  begin exit(result:=self.getChars(tCardinalArray([funcTextureID]),[funcBounds]));end;

function glCharArray.getChars(funcBounds:array of tBox):glCharArray;overload;
  var
    funcPointer:pointer;
    funcBoundsIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcBoundsIndex:=0 to high(funcBounds) do
              if pointInBox([(funcPointer+8)^,(funcPointer+12)^],funcBounds[funcBoundsIndex]) then
                begin
                  result[funcResultIndex]:=glChar(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glCharArray.getChars(funcBounds:tBox):glCharArray;overload;
  begin exit(result:=self.getChars([funcBounds]));end;


function glCharArray.indexes():integer;
  begin result:=length(self);end;

function glCharArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function glCharArray.maxIndex():integer;
  begin result:=high(self);end;

function glCharArray.minIndex():int32;
  begin result:=low(self);end;

function glCharArray.parseAlpha():glCharArray;
  var
    funcChar:int32;
    funcLength,
      funcResultIndex,
      funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        funcPointer:=pointer(self);
        for funcSelfIndex to high(self) do
          begin
            case funcChar:=(funcPointer+16)^ of
              65..90,97..122:
                begin
                  result[funcResultIndex]:=glChar(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                end;
            end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glCharArray.parseAlphaNumeric():glCharArray;
  var
    funcChar:int32;
    funcLength,
      funcResultIndex,
      funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        funcPointer:=pointer(self);
        for funcSelfIndex to high(self) do
          begin
            case funcChar:=(funcPointer+16)^ of
              48..57,65..90,97..122:
                begin
                  result[funcResultIndex]:=glChar(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                end;
            end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glCharArray.parseInt():glCharArray;
  var
    funcChar:int32;
    funcLength,
      funcResultIndex,
      funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        funcPointer:=pointer(self);
        for funcSelfIndex to high(self) do
          begin
            case funcChar:=(funcPointer+16)^ of
              48..57:
                begin
                  result[funcResultIndex]:=glChar(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                end;
            end;
            funcPointer:=funcPointer+48;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glCharArray.reverse():glCharArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;

function glCharArray.toInteger():int32;
  var
    funcChar:int32;
    funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if length(self) then
      begin
        funcPointer:=pointer(self);
        for funcSelfIndex to high(self) do
          case funcChar:=(funcPointer+16)^ of
            48..57:result:=funcChar-48+result*10;
          end;
      end;
    exit(result);
  end;

function glCharArray.toString():ansiString;
  var
    funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if length(self) then
      begin
        funcPointer:=pointer(self);
        for funcSelfIndex to high(self) do
          begin
            if (result<>'') and (single((funcPointer+20)^)-(single((funcPointer-28)^)+integer((funcPointer-8)^))<>0) then
              result:=result+' ';
            result:=result+char((funcPointer+16)^);
            funcPointer:=funcPointer+48;
          end;
      end;
    exit(result);
  end;



function glModel.adjustPosition(funcX,funcY:integer=0):glModel;
  begin result:=[self.ID,self.TID,self.x+funcX,self.y+funcY];end;


function glModel.closest(funcPointArray:tPointArray):tPointArray;
  begin result:=funcPointArray.closestTo(self);end;

function glModel.closest(funcModelArray:glModelArray):tPointArray;overload;
  begin result:=funcModelArray.closestTo(self);end;

function glModel.closest(funcTextureArray:glTextureArray):tPointArray;overload;
  begin result:=funcTextureArray.closestTo(self);end;

function glModel.distanceFrom(funcPoint:tPoint):int32;
  begin result:=round(sqrt(pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2)));end;

function glModel.distanceFrom(funcModel:glModel):extended;overload;
  begin result:=sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2));end;

function glModel.distanceFrom(funcTexture:glTexture):extended;overload;
  begin result:=sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2));end;

function glModel.isVisible():boolean;
  var
    funcSelfPoint:tPoint;
  begin
    funcSelfPoint:=[self.x,self.y];
    exit(result:=funcSelfPoint.isVisible());
  end;

function glModel.toPoint():tPoint;
  begin result:=[self.x,self.y];end;



function glModelArray.closestTo(funcPoint:tPoint):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcPoint);
      end;
    exit(result);
  end;

function glModelArray.closestTo(funcModel:glModel):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcModel.toPoint());
      end;
    exit(result);
  end;

function glModelArray.closestTo(funcTexture:glTexture):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcTexture.toPoint());
      end;
    exit(result);
  end;


function glModelArray.furthestFrom(funcPoint:tPoint):tPointArray;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcPoint);
        result:=result.reverse();
      end;
    exit(result);
  end;

function glModelArray.furthestFrom(funcModel:glModel):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcModel.toPoint());
        result:=result.reverse();
      end;
    exit(result);
  end;

function glModelArray.furthestFrom(funcTexture:glTexture):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcTexture.toPoint());
        result:=result.reverse();
      end;
    exit(result);
  end;

function glModelArray.getModels(funcID:array of uInt32):glModelArray;overload;
  var
    funcPointer:pointer;
    funcIDIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcIDIndex:=0 to high(funcID) do
              if funcPointer^=funcID[funcIDIndex] then
                begin
                  result[funcResultIndex]:=glModel(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                  break;
                end;
            funcPointer:=funcPointer+16;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glModelArray.getModels(funcID:uInt32):glModelArray;overload;
  begin exit(result:=self.getModels(tCardinalArray([funcID])));end;

function glModelArray.getModels(funcID:array of uInt32;funcBounds:array of tBox):glModelArray;overload;
  var
    funcBoundsIndex,
      funcIDIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcIDIndex:=0 to high(funcID) do
              if funcPointer^=funcID[funcIDIndex] then
                for funcBoundsIndex:=0 to high(funcBoundsIndex) do
                  if pointInBox([(funcPointer+8)^,(funcPointer+12)^],funcBounds[funcBoundsIndex]) then
                    begin
                      result[funcResultIndex]:=glModel(funcPointer^);
                      funcResultIndex:=funcResultIndex+1;
                      funcIDIndex:=high(funcID);
                      break;
                    end;
            funcPointer:=funcPointer+36;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glModelArray.getModels(funcID:uInt32;funcBounds:tBox):glModelArray;overload;
  begin exit(result:=self.getModels(tCardinalArray([funcID]),[funcBounds]));end;

function glModelArray.getModels(funcBounds:array of tBox):glModelArray;overload;
  var
    funcBoundsIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcBoundsIndex:=0 to high(funcBounds) do
              if pointInBox([(funcPointer+8)^,(funcPointer+12)^],funcBounds[funcBoundsIndex]) then
                begin
                  result[funcResultIndex]:=glModel(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                end;
            funcPointer:=funcPointer+16;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glModelArray.getModels(funcBounds:tBox):glModelArray;overload;
  begin  exit(result:=self.getModels([funcBounds]))end;


function glModelArray.getVisible():glModelArray;
  var
    funcBoxArray:array of tBox;
    funcBoxArrayIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex,
      funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if length(self) then
      begin
        funcPointer:=glxTextures(funcPointerSize);
        if funcPointer<>nil then
          begin
            setLength(funcBoxArray,funcPointerSize);
            for funcPointerIndex to funcPointerSize-1 do
              begin
                if (funcPointer^=3060) and ((funcPointer+180)^=28550) then
                  begin
                    funcBoxArray[funcBoxArrayIndex]:=[(funcPointer+20)^,(funcPointer+24)^,(funcPointer+208)^,(funcPointer+212)^];
                    funcBoxArrayIndex:=funcBoxArrayIndex+1;
                    funcPointer:=funcPointer+216;
                  end
                else if (funcPointer^=4080) and ((funcPointer+252)^=16320) then
                  begin
                    funcBoxArray[funcBoxArrayIndex]:=[(funcPointer+20)^,(funcPointer+24)^,(funcPointer+244)^,(funcPointer+248)^];
                    funcBoxArrayIndex:=funcBoxArrayIndex+1;
                    funcPointer:=funcPointer+288;
                  end
                else
                  funcPointer:=funcPointer+36;
              end;
            if funcBoxArrayIndex<>0 then
              begin
                setLength(funcBoxArray,funcBoxArrayIndex);
                setLength(result,length(self));
                for funcSelfIndex to high(self) do
                  begin
                    for funcBoxArrayIndex:=0 to high(funcBoxArray) do
                      begin
                        if pointInBox(self[funcSelfIndex].toPoint(),funcBoxArray[funcBoxArrayIndex]) then
                          break
                        else if funcBoxArrayIndex=high(funcBoxArray) then
                          begin
                            result[funcResultIndex]:=self[funcSelfIndex];
                            funcResultIndex:=funcResultIndex+1;
                          end;
                      end;
                  end;
                setLength(result,funcResultIndex);
              end;
          end;
      end;
    exit(result);
  end;



function glModelArray.indexes():integer;
  begin result:=length(self);end;

function glModelArray.isEmpty():boolean;
  begin result:=length(self)=0;end;

function glModelArray.maxIndex():int32;
  begin result:=high(self);end;

function glModelArray.minIndex():int32;
  begin result:=low(self);end;

function glModelArray.reverse():glModelArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;

function glModelArray.toPointArray():tPointArray;
  var
    funcIndex:uInt32=0;
  begin
    if length(self) then
      begin
        setLength(result,self.indexes());
        for funcIndex to self.maxIndex() do
          result[funcIndex]:=[self[funcIndex].x,self[funcIndex].y];
      end;
    exit(result);
  end;




function glTexture.adjustPosition(funcX,funcY:integer=0):glTexture;
  begin result:=[self.ID,self.colourID,self.fullColourID,self.x+funcX,self.y+funcY,[self.bounds.x1+funcX,self.bounds.y1+funcY,self.bounds.x2+funcX,self.bounds.y2+funcY]];end;

function glTexture.closest(funcPointArray:tPointArray):tPointArray;
  begin result:=funcPointArray.closestTo(self);end;

function glTexture.closest(funcModelArray:glModelArray):tPointArray;overload;
  begin result:=funcModelArray.closestTo(self);end;

function glTexture.closest(funcTextureArray:glTextureArray):tPointArray;overload;
  begin result:=funcTextureArray.closestTo(self);end;

function glTexture.distanceFrom(funcPoint:tPoint):extended;
  begin result:=sqrt(pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2));end;

function glTexture.distanceFrom(funcModel:glModel):extended;overload;
  begin result:=sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2));end;

function glTexture.distanceFrom(funcTexture:glTexture):extended;overload;
  begin result:=sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2));end;

function glTexture.isVisible():boolean;
  var
    funcSelfPoint:tPoint;
  begin
    funcSelfPoint:=[self.x,self.y];
    exit(result:=funcSelfPoint.isVisible());
  end;

function glTexture.toPoint():tPoint;
  begin result:=[self.x,self.y];end;



function glTextureArray.closestTo(funcPoint:tPoint):tPointArray;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcPoint);
      end;
    exit(result);
  end;

function glTextureArray.closestTo(funcModel:glModel):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcModel.toPoint());
      end;
    exit(result);
  end;

function glTextureArray.closestTo(funcTexture:glTexture):tPointArray;overload;
  begin
    result:=self.toPointArray();
    sortTPAFrom(result,funcTexture.toPoint());
  end;

function glTextureArray.furthestFrom(funcPoint:tPoint):tPointArray;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcPoint);
        result:=result.reverse();
      end;
    exit(result);
  end;

function glTextureArray.furthestFrom(funcModel:glModel):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcModel.toPoint());
        result:=result.reverse();
      end;
    exit(result);
  end;

function glTextureArray.furthestFrom(funcTexture:glTexture):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self.toPointArray();
        sortTPAFrom(result,funcTexture.toPoint());
        result:=result.reverse();
      end;
    exit(result);
  end;

function glTextureArray.getTextures(funcID:array of int32):glTextureArray;overload;
  var
    funcIDIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcIDIndex:=0 to high(funcID) do
              if funcPointer^=funcID[funcIDIndex] then
                begin
                  result[funcResultIndex]:=glTexture(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                  break;
                end;
            funcPointer:=funcPointer+36;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glTextureArray.getTextures(funcID:int32):glTextureArray;overload;
  begin exit(result:=self.getTextures([funcID]));end;

function glTextureArray.getTextures(funcID,funcColourID:array of int32):glTextureArray;overload;
  var
    funcColourIDIndex,
      funcIDIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcIDIndex:=0 to high(funcID) do
              if funcPointer^=funcID[funcIDIndex] then
                for funcColourIDIndex:=0 to high(funcColourID) do
                  if similarColors((funcPointer+4)^,funcColourID[funcColourIDIndex],oglColourTolerance) then
                    begin
                      result[funcResultIndex]:=glTexture(funcPointer^);
                      funcResultIndex:=funcResultIndex+1;
                      funcIDIndex:=high(funcID);
                      break;
                    end;
            funcPointer:=funcPointer+36;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glTextureArray.getTextures(funcID,funcColourID:int32):glTextureArray;overload;
  begin exit(result:=self.getTextures([funcID],[funcColourID]));end;

function glTextureArray.getTextures(funcID,funcColourID:array of int32;funcBounds:array of tBox):glTextureArray;overload;
  var
    funcBoundsIndex,
      funcColourIDIndex,
      funcIDIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcIDIndex:=0 to high(funcID) do
              if funcPointer^=funcID[funcIDIndex] then
                for funcColourIDIndex:=0 to high(funcColourID) do
                  if similarColors((funcPointer+4)^,funcColourID[funcColourIDIndex],oglColourTolerance) then
                    for funcBoundsIndex:=0 to high(funcBounds) do
                      if pointInBox([(funcPointer+12)^,(funcPointer+16)^],funcBounds[funcBoundsIndex]) then
                        begin
                          result[funcResultIndex]:=glTexture(funcPointer^);
                          funcResultIndex:=funcResultIndex+1;
                          funcIDIndex:=high(funcID);
                          funcColourIDIndex:=high(funcColourID);
                          break;
                        end;
            funcPointer:=funcPointer+36;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glTextureArray.getTextures(funcID,funcColour:int32;funcBounds:tBox):glTextureArray;overload;
  begin exit(result:=self.getTextures([funcID],[funcColour],[funcBounds]));end;

function glTextureArray.getTextures(funcID:array of int32;funcBounds:array of tBox):glTextureArray;overload;
  var
    funcBoundsIndex,
      funcIDIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcIDIndex:=0 to high(funcID) do
              if funcPointer^=funcID[funcIDIndex] then
                for funcBoundsIndex:=0 to high(funcBounds) do
                  if pointInBox([(funcPointer+12)^,(funcPointer+16)^],funcBounds[funcBoundsIndex]) then
                    begin
                      result[funcResultIndex]:=glTexture(funcPointer^);
                      funcResultIndex:=funcResultIndex+1;
                    end;
            funcPointer:=funcPointer+36;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glTextureArray.getTextures(funcID:int32;funcBounds:tBox):glTextureArray;overload;
  begin exit(result:=self.getTextures([funcID],[funcBounds]));end;

function glTextureArray.getTextures(funcBounds:array of tBox):glTextureArray;overload;
  var
    funcBoundsIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex:uInt32=0;
    funcPointer:pointer;
  begin
    funcPointer:=pointer(self);
    if funcPointer<>nil then
      begin
        setLength(result,funcPointerSize:=length(self));
        for funcPointerIndex to funcPointerSize-1 do
          begin
            for funcBoundsIndex:=0 to high(funcBounds) do
              if pointInBox([(funcPointer+12)^,(funcPointer+16)^],funcBounds[funcBoundsIndex]) then
                begin
                  result[funcResultIndex]:=glTexture(funcPointer^);
                  funcResultIndex:=funcResultIndex+1;
                end;
            funcPointer:=funcPointer+36;
          end;
        setLength(result,funcResultIndex);
      end;
    exit(result);
  end;

function glTextureArray.getTextures(funcBounds:tBox):glTextureArray;overload;
  begin exit(result:=self.getTextures([funcBounds]));end;

function glTextureArray.indexes():integer;
  begin result:=length(self);end;

function glTextureArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function glTextureArray.maxIndex():int32;
  begin result:=high(self);end;

function glTextureArray.minIndex():int32;
  begin result:=low(self);end;

function glTextureArray.reverse():glTextureArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;

function glTextureArray.toPointArray():tPointArray;
  var
    funcIndex:uInt32=0;
  begin
    if length(self) then
      begin
        setLength(result,self.indexes());
        for funcIndex to self.maxIndex() do
          result[funcIndex]:=[self[funcIndex].x,self[funcIndex].y];
      end;
    exit(result);
  end;

function tBox.adjustPosition(funcX1,funcY1,funcX2,funcY2:integer=0):tBox;
  begin result:=[self.x1+funcX1,self.y1+funcY1,self.x2+funcX2,self.y2+funcY2];end;

function tBoxArray.indexes():integer;
  begin result:=length(self);end;

function tBoxArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function tBoxArray.maxIndex():int32;
  begin result:=high(self);end;

function tBoxArray.minIndex():int32;
  begin result:=low(self);end;

function tBoxArray.reverse():tBoxArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;

function tCardinalArray.contains(funcID:uInt32):boolean;
  var
    funcPointer:pointer;
    funcPointerIndex:uInt32=0;
  begin
    if length(self) then
      begin
        funcPointer:=pointer(self);
        for funcpointerIndex to high(self) do
          begin
            if funcPointer^=funcID then
              begin
                result:=true;
                break;
              end;
            funcPointer:=funcPointer+4;
          end;
      end;
    exit(result);
  end;

function tCardinalArray.indexes():integer;
  begin result:=length(self);end;

function tCardinalArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function tCardinalArray.maxIndex():int32;
  begin result:=high(self);end;

function tCardinalArray.minIndex():int32;
  begin result:=low(self);end;

function tIntegerArray.contains(funcID:uInt32):boolean;
  var
    funcPointer:pointer;
    funcPointerIndex:uInt32=0;
  begin
    if length(self) then
      begin
        funcPointer:=pointer(self);
        for funcpointerIndex to high(self) do
          begin
            if funcPointer^=funcID then
              begin
                result:=true;
                break;
              end;
            funcPointer:=funcPointer+4;
          end;
      end;
    exit(result);
  end;

function tIntegerArray.indexes():integer;
  begin result:=length(self);end;

function tIntegerArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function tIntegerArray.maxIndex():int32;
  begin result:=high(self);end;

function tIntegerArray.minIndex():int32;
  begin result:=low(self);end;

function tIntegerArray.reverse():tIntegerArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;

function tPoint.adjustPosition(funcX,funcY:integer=0):tPoint;
  begin result:=[self.x+funcX,self.y+funcY];end;

function tPoint.closest(funcPointArray:tPointArray):tPointArray;
  begin result:=funcPointArray.closestTo(self);end;

function tPoint.closest(funcModelArray:glModelArray):tPointArray;overload;
  begin result:=funcModelArray.closestTo(self);end;

function tPoint.closest(funcTextureArray:glTextureArray):tPointArray;overload;
  begin result:=funcTextureArray.closestTo(self);end;

function tPoint.distanceFrom(funcPoint:tPoint):extended;
  begin result:=sqrt(pow(self.x-funcPoint.x,2)+pow(self.y-funcPoint.y,2));end;

function tPoint.distanceFrom(funcModel:glModel):extended;overload;
  begin result:=sqrt(pow(self.x-funcModel.x,2)+pow(self.y-funcModel.y,2));end;

function tPoint.distanceFrom(funcTexture:glTexture):extended;overload;
  begin result:=sqrt(pow(self.x-funcTexture.x,2)+pow(self.y-funcTexture.y,2));end;

function tPoint.isVisible():boolean;
  var
    funcPointer:pointer;
    funcPointerIndex,
      funcPointerSize:uInt32=0;
  begin
    funcPointer:=glxTextures(funcPointerSize);
    if funcPointer<>nil then
      begin
        for funcPointerIndex to funcPointerSize-1 do
          begin
            if (funcPointer^=3060) and ((funcPointer+180)^=28550) then
              begin
                if pointInBox(self,[(funcPointer+20)^,(funcPointer+24)^,(funcPointer+208)^,(funcPointer+212)^]) then
                  begin
                    result:=true;
                    break;
                  end
                else
                  funcPointer:=funcPointer+216;
              end
            else if (funcPointer^=4080) and ((funcPointer+252)^=16320) then
              begin
                if pointInBox(self,[(funcPointer+20)^,(funcPointer+24)^,(funcPointer+244)^,(funcPointer+248)^]) then
                  begin
                    result:=true;
                    break;
                  end
                else
                  funcPointer:=funcPointer+288;
              end
            else
              funcPointer:=funcPointer+36;
          end;
      end;
    exit(result);
  end;

function tPoint.randomizePoint(funcX,funcY:int32=0):tPoint;
  begin
    result:=[self.x+random(funcX div 2*-1,funcX div 2),self.y+random(funcY div 2*-1,funcY div 2)];
  end;

function tPoint.randomizePointEllipse(funcDiameter:int32):tPoint;
  var
    funcAngle,
      funcRadius,
      funcRandom:extended;
  begin
    result:=[self.x+round((funcRadius:=funcDiameter div 2)*(funcRandom:=random())*cos(funcAngle:=random()*(pi*2))),self.y+round((funcRadius*funcRandom)*sin(funcAngle))];
  end;

function tPointArray.closestTo(funcPoint:tPoint):tPointArray;
  begin
    if length(self) then
      begin
        result:=self;
        sortTPAFrom(result,funcPoint);
      end;
    exit(result);
  end;

function tPointArray.closestTo(funcModel:glModel):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self;
        sortTPAFrom(result,funcModel.toPoint());
      end;
    exit(result);
  end;

function tPointArray.closestTo(funcTexture:glTexture):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self;
        sortTPAFrom(result,funcTexture.toPoint());
      end;
    exit(result);
  end;

function tPointArray.furthestFrom(funcPoint:tPoint):tPointArray;
  begin
    if length(self) then
      begin
        result:=self;
        sortTPAFrom(result,funcPoint);
        result:=result.reverse();
      end;
    exit(result);
  end;

function tPointArray.furthestFrom(funcModel:glModel):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self;
        sortTPAFrom(result,funcModel.toPoint());
        result:=result.reverse();
      end;
    exit(result);
  end;

function tPointArray.furthestFrom(funcTexture:glTexture):tPointArray;overload;
  begin
    if length(self) then
      begin
        result:=self;
        sortTPAFrom(result,funcTexture.toPoint());
        result:=result.reverse();
      end;
    exit(result);
  end;

function tPointArray.getVisible():tPointArray;
  var
    funcBoxArray:array of tBox;
    funcBoxArrayIndex,
      funcPointerIndex,
      funcPointerSize,
      funcResultIndex,
      funcSelfIndex:uInt32=0;
    funcPointer:pointer;
  begin
    if length(self) then
      begin
        funcPointer:=glxTextures(funcPointerSize);
        if funcPointer<>nil then
          begin
            setLength(funcBoxArray,funcPointerSize);
            for funcPointerIndex to funcPointerSize-1 do
              begin
                if (funcPointer^=3060) and ((funcPointer+180)^=28550) then
                  begin
                    funcBoxArray[funcBoxArrayIndex]:=[(funcPointer+20)^,(funcPointer+24)^,(funcPointer+208)^,(funcPointer+212)^];
                    funcBoxArrayIndex:=funcBoxArrayIndex+1;
                    funcPointer:=funcPointer+216;
                  end
                else if (funcPointer^=4080) and ((funcPointer+252)^=16320) then
                  begin
                    funcBoxArray[funcBoxArrayIndex]:=[(funcPointer+20)^,(funcPointer+24)^,(funcPointer+244)^,(funcPointer+248)^];
                    funcBoxArrayIndex:=funcBoxArrayIndex+1;
                    funcPointer:=funcPointer+288;
                  end
                else
                  funcPointer:=funcPointer+36;
              end;
            if funcBoxArrayIndex<>0 then
              begin
                setLength(funcBoxArray,funcBoxArrayIndex);
                setLength(result,length(self));
                for funcSelfIndex to high(self) do
                  begin
                    for funcBoxArrayIndex:=0 to high(funcBoxArray) do
                      begin
                        if pointInBox(self[funcSelfIndex],funcBoxArray[funcBoxArrayIndex]) then
                          break
                        else if funcBoxArrayIndex=high(funcBoxArray) then
                          begin
                            result[funcResultIndex]:=self[funcSelfIndex];
                            funcResultIndex:=funcResultIndex+1;
                          end;
                      end;
                  end;
                setLength(result,funcResultIndex);
              end;
          end;
      end;
    exit(result);
  end;

function tPointArray.indexes():integer;
  begin result:=length(self);end;

function tPointArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function tPointArray.maxIndex():int32;
  begin result:=high(self);end;

function tPointArray.minIndex():int32;
  begin result:=low(self);end;

function tPointArray.reverse():tPointArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;



function tStringArray.indexes():integer;
  begin result:=length(self);end;

function tStringArray.isEmpty():boolean;
  begin result:=pointer(self)=nil;end;

function tStringArray.maxIndex():int32;
  begin result:=high(self);end;

function tStringArray.minIndex():int32;
  begin result:=low(self);end;

function tStringArray.reverse():tStringArray;
  var
    funcIndex,
      funcLength,
      funcMaxIndex:uInt32;
  begin
    if funcLength:=length(self) then
      begin
        setLength(result,funcLength);
        for funcIndex:=0 to funcMaxIndex:=high(self) do
          result[funcMaxIndex-funcIndex]:=self[funcIndex];
      end;
    exit(result);
  end;
